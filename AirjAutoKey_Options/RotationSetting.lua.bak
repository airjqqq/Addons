local parent = AirjAutoKey_Options
local mod = {}
local AirjAutoKey = AirjAutoKey
local AceGUI = LibStub("AceGUI-3.0")

local typeList
local typeOrder
local typeDesc
do
	local list = {["_"] = "未定义"}
	local order = {"_"}
	local descs = {"请选择"}
	list["GROUP"] = "组"
	tinsert(order,"GROUP")
	tinsert(descs,"使用组")
	list["FCN"] = "自定义函数"
	tinsert(order,"FCN")
	tinsert(descs,"使用自定义函数")
	for k,v in pairs(AirjAutoKey.filterTypes) do
		list[k] = v.name
		tinsert(order,k)
		local desc = v.desc or ""
		if desc == "" then
			desc = v.name
		end
		tinsert(descs,desc)
	end
	typeList = list
	typeOrder = order
	typeDesc = descs
end

local function SetDescription(widget,desc)
		widget:SetCallback("OnEnter",function(widget) 
			GameTooltip:SetOwner(widget.frame, "ANCHOR_TOPRIGHT");
			GameTooltip:AddLine(desc, 1, 1, 1, 1);
			GameTooltip:Show();
			GameTooltip:SetFrameLevel(50);
		end)
		widget:SetCallback("OnLeave", function(widget) 
			GameTooltip:Hide()
		end)
end

local spellConfigWidgets = {
	{
		key = "spell",
		widget = "EditBox",
		text = "技能名称",
		desc = "需要与[按键设置]中的技能名完全一致",
		width = 240,
		layoutGroup = 1,
	},
	{
		key = "note",
		widget = "EditBox",
		text = "注释",
		desc = "会显示在左面的列表中,方便查找",
		width = 240,
		layoutGroup = 3,
	},
	{
		key = "heading",
		widget = "SimpleGroup",
		text = "",
		width = "fill",
	},
	{
		key = "upper",
		widget = "Button",
		text = "上移",
		desc = "",
		layoutGroup = 2,
	},
	{
		key = "lower",
		widget = "Button",
		text = "下移",
		desc = "",
		layoutGroup = 2,
	},
	{
		key = "new",
		widget = "Button",
		text = "新建",
		desc = "",
		layoutGroup = 2,
	},
	{
		key = "inport",
		widget = "Button",
		text = "导入",
		desc = "",
		layoutGroup = 4,
	},
	{
		key = "export",
		widget = "Button",
		text = "导出",
		desc = "",
		layoutGroup = 4,
	},
	{
		key = "delete",
		widget = "Button",
		text = "删除",
		desc = "",
		layoutGroup = 4,
	},
	{
		key = "heading",
		widget = "SimpleGroup",
		text = "",
		width = "fill",
	},
	{
		key = "icon",
		widget = "EditBox",
		text = "图标名称(或路径)",
		desc = "留空则使用技能图标",
		width = 480,
		layoutGroup = 5,
	},
	{
		key = "heading",
		widget = "SimpleGroup",
		text = "",
		width = "fill",
	},
	{
		key = "tarmin",
		widget = "Slider",
		text = "最小目标数",
		min = 0,
		max = 10,
		step = 1,
		desc = "",
		width = 240,
		layoutGroup = 6,
	},
	{
		key = "tarmax",
		widget = "Slider",
		text = "最大目标数",
		min = 0,
		max = 10,
		step = 1,
		desc = "",
		width = 240,
		layoutGroup = 6,
	},
}

local filterConfigWidgets = {
	{
		key = "type",
		widget = "Dropdown",
		text = "选择类型",
		desc = "",
		width = 160,
	},
	{
		key = "subtype",
		widget = "Dropdown",
		text = "子类型",
		desc = "",
		width = 160,
	},
	{
		key = "note",
		widget = "EditBox",
		text = "注释",
		desc = "会显示在左面的列表中,方便查找",
		width = 160,
	},
	{
		key = "oppo",
		widget = "CheckBox",
		text = "翻转结果",
		desc = "选中则翻转结果",
		width = 160,
	},
	{
		key = "heading",
		widget = "SimpleGroup",
		text = "",
		width = "fill",
	},
	
	{
		key = "new",
		widget = "Button",
		text = "新建",
		desc = "",
		layoutGroup = layoutGroupsIndex,
	},
	{
		key = "inport",
		widget = "Button",
		text = "导入",
		desc = "",
		layoutGroup = layoutGroupsIndex,
	},
	{
		key = "export",
		widget = "Button",
		text = "导出",
		desc = "",
		layoutGroup = layoutGroupsIndex,
	},
	{
		key = "delete",
		widget = "Button",
		text = "删除",
		desc = "",
		layoutGroup = layoutGroupsIndex,
	},
	
	{
		key = "heading",
		widget = "SimpleGroup",
		text = "",
		width = "fill",
	},
	{
		key = "name",
		widget = "EditBox",
		text = "名称",
		desc = "",
		width = 160,
	},
	{
		key = "unit",
		widget = "EditBox",
		text = "单位",
		desc = "",
		width = 160,
	},
	{
		key = "greater",
		widget = "CheckBox",
		text = "大于",
		desc = "",
		width = 160,
	},
	{
		key = "value",
		widget = "EditBox",
		text = "数值",
		desc = "",
		width = 160,
	},
}
function mod:CreateSpellConfigGroup()
	local group = AceGUI:Create("ScrollFrame")
	group:SetLayout("Flow")
	for i,v in ipairs(spellConfigWidgets) do 
		local widget = AceGUI:Create(v.widget)
		if widget.SetLabel then
			widget:SetLabel(v.text)
		elseif widget.SetText then
			widget:SetText(v.text)
		end
		if v.min and v.max and v.step and widget.SetSliderValues then
			widget:SetSliderValues(v.min,v.max,v.step)
		end
		SetDescription(widget,v.desc)
		if v.width == "fill" then
			widget:SetFullWidth(true)
		elseif v.width == "x2" then
			widget:SetWidth(160)
		else
			widget:SetWidth(v.width or 80)
		end
		group:AddChild(widget)
		group[v.key] = widget
	end
	
	group.spell:SetCallback("OnEnterPressed",function(widget,event,text) 
		if text == "" then
			text = "等待"
		end
		self.currentSpellArray[self.currentSpellIndex].spell = text 
		self:RotationSetting()
	end)
	
	group.upper:SetCallback("OnClick", function(widget,event)
		local currentSpellIndex = self.currentSpellIndex
		local swapSpellIndex = currentSpellIndex - 1
		if swapSpellIndex == 0 then
			return
		end
		local tmpSpell = self.currentSpellArray[swapSpellIndex]
		self.currentSpellArray[swapSpellIndex] = self.currentSpellArray[currentSpellIndex]
		self.currentSpellArray[currentSpellIndex] = tmpSpell
		self.currentSpellIndex = swapSpellIndex
		self:RotationSetting()
	end)
	
	group.lower:SetCallback("OnClick", function(widget,event)
		local currentSpellIndex = self.currentSpellIndex
		local swapSpellIndex = currentSpellIndex + 1
		if swapSpellIndex == #(self.currentSpellArray) + 1 then
			return
		end
		local tmpSpell = self.currentSpellArray[swapSpellIndex]
		self.currentSpellArray[swapSpellIndex] = self.currentSpellArray[currentSpellIndex]
		self.currentSpellArray[currentSpellIndex] = tmpSpell
		self.currentSpellIndex = swapSpellIndex
		self:RotationSetting()
	end)
	
	group.new:SetCallback("OnClick", function(widget,event)
		local currentSpellIndex = self.currentSpellIndex
		self:NewSpell({},currentSpellIndex+1)
		self.currentSpellIndex = currentSpellIndex + 1
		self:RotationSetting()
	end)
	
	group.note:SetCallback("OnEnterPressed",function(widget,event,text) 
		if text == "" then
			text = nil
		end
		self.currentSpellArray[self.currentSpellIndex].note = text 
		self:RotationSetting()
	end)
	
	group.inport:SetCallback("OnClick", function(widget,event)
		parent.inportStatus = {self.currentFilterPath,self.currentSpellIndex}
		parent:Inport()
	end)
	
	group.export:SetCallback("OnClick", function(widget,event)
		parent:Export("spell",self.currentSpellArray[self.currentSpellIndex])
	end)

	group.delete:SetCallback("OnClick", function(widget,event)
		tremove(self.currentSpellArray,self.currentSpellIndex)
		self:RotationSetting()
	end)
	
	group.icon:SetCallback("OnEnterPressed",function(widget,event,text) 
		if text == "" then
			text = nil
		end
		self.currentSpellArray[self.currentSpellIndex].icon = text 
	end)
	
	group.tarmin:SetCallback("OnMouseUp", function(widget,event,value)
		self.currentSpellArray[self.currentSpellIndex].tarmin = value 
	end)
	
	group.tarmax:SetCallback("OnMouseUp", function(widget,event,value)
		self.currentSpellArray[self.currentSpellIndex].tarmax = value 
	end)
	
	--filters stuff
	local filtersHeading = AceGUI:Create("Heading")
	filtersHeading:SetText("过滤器")
	filtersHeading:SetFullWidth(true)
	group:AddChild(filtersHeading)
	
	local filtersGroup = AceGUI:Create("TreeGroup")
	group:AddChild(filtersGroup)
	group.filtersGroup = filtersGroup
	
	filtersGroup:SetFullWidth(true)
	filtersGroup:SetTree({})
	filtersGroup:SetCallback("OnGroupSelected",function(widget,event,group)
		self.currentFilterPath = group
		self:UpdateFilterConfigGroup()
	end)
	
	filtersGroup:SetLayout("Flow")
	for i,v in ipairs(filterConfigWidgets) do 
		local widget = AceGUI:Create(v.widget)
		if widget.SetLabel then
			widget:SetLabel(v.text)
		elseif widget.SetText then
			widget:SetText(v.text)
		end
		if v.min and v.max and v.step and widget.SetSliderValues then
			widget:SetSliderValues(v.min,v.max,v.step)
		end
		SetDescription(widget,v.desc)
		if v.width == "fill" then
			widget:SetFullWidth(true)
		elseif v.width == "x2" then
			widget:SetWidth(160)
		else
			widget:SetWidth(v.width or 80)
		end
		filtersGroup:AddChild(widget)
		group["filter_"..v.key] = widget
	end
	
	group.filter_type:SetList(typeList,typeOrder)
	for k,v in group.filter_type.pullout:IterateItems() do
		SetDescription(v,typeDesc[k])
	end
	group.filter_type:SetCallback("OnValueChanged",function(widget,event,key)
		local filter = self:GetCurrentSpellFilter() 
		filter.type = key
		self:UpdateFilterTreeGroup()
	end)
	
	group.filter_subtype:SetCallback("OnValueChanged",function(widget,event,key)
		local filter = self:GetCurrentSpellFilter() 
		filter.subtype = key
	end)
	
	group.filter_note:SetCallback("OnEnterPressed",function(widget,event,text)
		local filter = self:GetCurrentSpellFilter() 
		if text == "" then
			text = nil
		end
		filter.note = text
		self:UpdateFilterTreeGroup()
	end)
	
	group.filter_oppo:SetCallback("OnValueChanged",function(widget,event,checked)
		local filter = self:GetCurrentSpellFilter() 
		filter.oppo = checked or nil
	end)
	
	group.filter_new:SetCallback("OnClick",function(widget,event)
		self.currentFilterPath = self:NextFilterPath()
		self:NewFilter({})
	end)
	
	group.filter_inport:SetCallback("OnClick", function(widget,event)
		parent.inportStatus = {self.currentFilterPath,self.currentSpellIndex}
		parent:Inport()
	end)
	
	group.filter_export:SetCallback("OnClick", function(widget,event)
		local filter = self:GetCurrentSpellFilter() 
		parent:Export("filter",filter)
	end)
	group.filter_delete:SetCallback("OnClick", function(widget,event)
		local spell = self.currentSpellArray[self.currentSpellIndex]
		local pathstr = {strsplit("\001",self.currentFilterPath)}
		local paths = {}
		for i,v in ipairs(pathstr) do
			paths[i] = tonumber(v)
		end
		local filter = spell.filter
		for i = 1,#paths -1 do
			filter = filter[paths[i]]
		end
		tremove(filter,paths[#paths])
		self:UpdateFilterTreeGroup()
	end)
	
	group.filter_name:SetCallback("OnEnterPressed",function(widget,event,text)
		local filter = self:GetCurrentSpellFilter() 
		local nameTable = {strsplit(",",text)}
		if #nameTable <=1 then
			if text == "" then
				text = nil
			elseif tonumber(text) then
				text = tonumber(text)
			end
			filter.name = text
		else
			local tab = {}
			for k,v in pairs(nameTable) do
				tab[k] = tonumber(v) or v
			end
			filter.name = tab
		end
	end)
	
	group.filter_unit:SetCallback("OnEnterPressed",function(widget,event,text)
		local filter = self:GetCurrentSpellFilter() 
		if text == "" then
			text = nil
		end
		filter.unit = text
	end)
	
	group.filter_greater:SetCallback("OnValueChanged",function(widget,event,checked)
		local filter = self:GetCurrentSpellFilter() 
		filter.greater = checked or nil
	end)
	
	group.filter_value:SetCallback("OnEnterPressed",function(widget,event,text)
		local filter = self:GetCurrentSpellFilter() 
		if text == "" then
			text = nil
		elseif tonumber(text) then
			text = tonumber(text)
		end
		filter.value = text
	end)
	
	self.spellConfigGroup = group
end

function mod:NextFilterPath(path)
	path = path or self.currentFilterPath 
	local filter = self:GetCurrentSpellFilter() 
	local pathstr = {strsplit("\001",path)}
	local paths = {}
	for i,v in ipairs(pathstr) do
		paths[i] = tonumber(v)
	end
	if not filter then
	elseif filter.group or filter.type == "GROUP" then
		paths[#paths+1] = 1
	else
		paths[#paths] = paths[#paths] + 1
	end
	local path = table.concat(paths,"\001")
	return tonumber(path) or path
end

local function GetFilter(filter,path)
	if path and path ~= "" then
		local thisPath, nextPath = strsplit("\001",path,2)
		return GetFilter(filter[tonumber(thisPath)],nextPath)
	else
		return filter
	end
end

function mod:GetCurrentSpellFilter() 
	local spell = self.currentSpellArray[self.currentSpellIndex]
	local path = self.currentFilterPath
	return GetFilter(spell.filter,path)
end

function mod:UpdateSpellTreeGroup()
	local spellArray = self.currentSpellArray
	local mainGroup = self.mainGroup
	local tree = {}
	for i,v in ipairs(spellArray) do
		local spellName = strsplit("_", v.spell or "") or ""
		local icon = GetSpellTexture(v.icon or "") or v.icon or GetSpellTexture(spellName)
		local text = v.spell or "未定义"
		if v.note then
			text = text.." - "..v.note
		end
		tinsert(tree,{value = i,text = text,icon = icon,})
	end
	mainGroup:SetTree(tree,true)
	mainGroup:Select(self.currentSpellIndex)
	self:UpdateSpellConfigGroup()
end

function mod:UpdateSpellConfigGroup()
	local group = self.spellConfigGroup
	if not group then
		return
	end
	for k,v in pairs(spellConfigWidgets) do
		local key = v.key
		if key and group[key] and group[key].SetDisabled then
			group[key]:SetDisabled(self.isDefault or self.isDefault)
		end
	end
	group.export:SetDisabled(false)
	local index = self.currentSpellIndex
	local spell = self.currentSpellArray[index] or {}
	group.spell:SetText(spell.spell or "未定义")
	group.upper:SetDisabled(self.isDefault or index == 1)
	group.lower:SetDisabled(self.isDefault or index == #self.currentSpellArray)
	group.note:SetText(spell.note or "")
	local spellName = strsplit("_", spell.spell or "")
	local icon = GetSpellTexture(spell.icon or "") or spell.icon or GetSpellTexture(spellName) or ""
	group.icon:SetText(icon)
	group.tarmin:SetValue(spell.tarmin or 1)
	group.tarmax:SetValue(spell.tarmax or 10)
	self:UpdateFilterTreeGroup()
	group:DoLayout()
end

function mod:GetFilterTreeElement(filter,isRoot)
	local element = {}
	if filter.group or filter.type == "GROUP" or isRoot then
		element.children = {}
		for k,v in ipairs(filter) do
			element.children[k] = self:GetFilterTreeElement(v)
			element.children[k].value = k
		end
	end
	element.text = filter.type and typeList[filter.type] or filter.fcn and typeList.FCN or filter.group and typeList.GROUP or "未定义"
	if filter.note then
		element.text = element.text.." - "..filter.note
	end
	return isRoot and element.children or element
end

function mod:UpdateFilterTreeGroup()
	local index = self.currentSpellIndex
	local spell = self.currentSpellArray[index] or {}
	local filterArray = spell.filter or {}
	local group = self.spellConfigGroup
	local filtersGroup = group.filtersGroup
	local tree = self:GetFilterTreeElement(filterArray,true)
	filtersGroup:SetTree(tree,true)
	filtersGroup:SelectByValue(tonumber(self.currentFilterPath) or self.currentFilterPath)
end

function mod:UpdateFilterConfigGroup()
	local group = self.spellConfigGroup
	for k,v in pairs(filterConfigWidgets) do
		local key = "filter_"..v.key
		if key and group[key] and group[key].SetDisabled then
			group[key]:SetDisabled(self.isDefault)
		end
	end
	group.filter_export:SetDisabled(false)
	local currentFilter = self:GetCurrentSpellFilter() or {}
	local maintype,subtype = currentFilter.type,currentFilter.subtype
	if not maintype and currentFilter.fcn then
		maintype,subtype = "FCN",currentFilter.fcn
	elseif not maintype and currentFilter.group then 
		maintype = "GROUP"
	end
	group.filter_type:SetValue(maintype or "_")
	self:UpdateFilterConfigGroupType()
	group.filter_subtype:SetValue(subtype and tostring(subtype) or subtype or "_")
	group.filter_oppo:SetValue(currentFilter.oppo)
	local nameText = currentFilter.name
	if type(nameText) == "table" then
		nameText = table.concat(nameText,",")
	end
	group.filter_name:SetText(nameText)
	group.filter_note:SetText(currentFilter.note)
	group.filter_unit:SetText(currentFilter.unit)
	group.filter_value:SetText(currentFilter.value or currentFilter.value or 0)
	group.filter_greater:SetValue(currentFilter.greater)
end

function mod:UpdateFilterConfigGroupType()
	local filter = self:GetCurrentSpellFilter() or {}
	local key = filter.type
	if key == self.lastType then
		return
	end
	self.lastType = key
	local typeInfo = AirjAutoKey.filterTypes[key] or {}
	local keys = typeInfo.keys or {}
	local subtypes = typeInfo.subtypes
	if key == "GROUP" then
		keys = {
			unit = {desc = "'raid'搜索全队"},
			value = {name = "数量",desc = "unit = 'raid'时的数量"},
			greater = {},
		}
		filter.group = true
	else
		filter.group = nil
	end
	
	local group = self.spellConfigGroup
	if key == "FCN" then
		group.filter_subtype:SetDisabled(self.isDefault or false)
		group.filter_subtype:SetLabel("自定义函数")
		local list = {_ = "请选择"}
		group.filter_subtype:SetList(list)
	elseif subtypes then
		group.filter_subtype:SetDisabled(self.isDefault or false)
		group.filter_subtype:SetLabel("子类型")
		local list = {_ = "默认"}
		for k,v in pairs(subtypes) do
			list[tostring(k)] = v.name
		end
		group.filter_subtype:SetList(list)
	else
		group.filter_subtype:SetDisabled(self.isDefault or true)
		group.filter_subtype:SetLabel("无可用子类型")
		local list = {_ = "默认"}
		group.filter_subtype:SetList(list)
	end
	local infoKeys = 
	{
		"name",
		"unit",
		"value",
		"greater",
	}
	local default = 
	{
		["name"] = "名称",
		["unit"] = "单位",
		["value"] = "数值",
		["greater"] = "大于",
	}
	
	local defaultDesc = 
	{
		["name"] = "名称",
		["unit"] = "单位",
		["value"] = "数值",
		["greater"] = "选中则为小于等于,否则为大于",
	}
	
	for k,v in pairs(infoKeys) do
		local widget = group["filter_"..v]
		if keys[v] then
			widget:SetDisabled(self.isDefault or false)
			widget:SetLabel(keys[v].name or default[v])
			SetDescription(widget,keys[v].desc or keys[v].name or defaultDesc[v] or "")
		else
			widget:SetDisabled(self.isDefault or true)
			widget:SetLabel(default[v])
			SetDescription(widget,defaultDesc[v] or default[v] or "")
		end
	end
			
end

function mod:NewSpell(spell,index)
	local spellArray = self.currentSpellArray
	if not index then 
		index = self.currentSpellIndex 
	else
		self.currentSpellIndex = index
	end
	spell.filter = spell.filter or {}
	tinsert(spellArray,index,spell)
	self:RotationSetting()
end

function mod:NewFilter(filter,index,path)
	if not path then 
		path = self.currentFilterPath 
	else
		self.currentFilterPath = path
	end
	if not index then 
		index = self.currentSpellIndex 
	else
		self.currentSpellIndex = index
	end
	local pathstr = {strsplit("\001",path)}
	local paths = {}
	for i,v in ipairs(pathstr) do
		paths[i] = tonumber(v)
	end
	local lastPath = paths[#paths]
	paths[#paths] = nil
	local parentPath = table.concat(paths,"\001")
	local spell = self.currentSpellArray[index]
	local parentFilter = GetFilter(spell.filter,parentPath)
	tinsert(parentFilter,lastPath,filter)
	self:UpdateFilterTreeGroup()
end

function mod:RotationSetting()
	local mainGroup = self.mainGroup
	if not mainGroup then
		mainGroup = AceGUI:Create("TreeGroup")
		mainGroup:SetCallback("OnGroupSelected",function(widget,event,uniquevalue)
			self.currentSpellIndex = uniquevalue
			self.currentFilterPath = 1
			self:UpdateSpellConfigGroup()
		end)
		self.mainGroup = mainGroup
		local tabGroup = parent.tabGroup
		tabGroup:AddChild(mainGroup)
	end
	if not self.spellConfigGroup then
		self:CreateSpellConfigGroup()
		mainGroup:SetLayout("Fill")
		mainGroup:AddChild(self.spellConfigGroup)
	end
	self:UpdateSpellTreeGroup()
	parent:SelectTab(mainGroup)
end

function parent:RotationSetting()
	if mod.currentSpellArray ~= AirjAutoKey.spellArray then
		mod.currentSpellArray = AirjAutoKey.spellArray or {}
		mod.currentSpellIndex = 1
		mod.currentFilterPath = 1
		mod.isDefault = AirjAutoKey.rotationDB.isDefault
	end
	mod:RotationSetting()
end

parent:RegisterTab("RotationSetting","循环设置",mod)