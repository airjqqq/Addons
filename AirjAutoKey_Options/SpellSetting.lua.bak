local parent = AirjAutoKey_Options
local mod = {}
local AirjAutoKey = AirjAutoKey
local AceGUI = LibStub("AceGUI-3.0")

local typeList
local typeOrder
local typeDesc
do
	local list = {["_"] = "未定义"}
	local order = {"_"}
	local descs = {"请选择"}
	list["GROUP"] = "组"
	tinsert(order,"GROUP")
	tinsert(descs,"使用组")
	list["FCN"] = "自定义函数"
	tinsert(order,"FCN")
	tinsert(descs,"使用自定义函数")
	local sorted = {}
	local filterTypes = AirjAutoKey.filterTypes
	for k,v in pairs(filterTypes) do
		sorted[v.order] = k
	end
	for i,k in pairs(sorted) do
		local v = filterTypes[k]
		list[k] = v.name
		tinsert(order,k)
		local desc = v.desc or ""
		if desc == "" then
			desc = v.name
		end
		tinsert(descs,desc)
	end
	typeList = list
	typeOrder = order
	typeDesc = descs
end

local function SetDescription(widget,desc)
	widget:SetCallback("OnEnter",function(widget) 
		GameTooltip:SetOwner(widget.frame, "ANCHOR_TOPRIGHT");
		GameTooltip:AddLine(desc, 1, 1, 1, 1);
		GameTooltip:Show();
		GameTooltip:SetFrameLevel(50);
	end)
	widget:SetCallback("OnLeave", function(widget) 
		GameTooltip:Hide()
	end)
end

local spellConfigWidgets = {
	{
		key = "spell",
		widget = "EditBox",
		text = "技能名称",
		desc = "需要与[按键设置]中的技能名完全一致",
			width = "x2",
	},
	{
		key = "note",
		widget = "EditBox",
		text = "注释",
		desc = "会显示在左面的列表中,方便查找",
			width = "x2",
	},
	{
		key = "disable",
		widget = "CheckBox",
		text = "禁用",
		desc = "",
	},
	{
		key = "continue",
		widget = "CheckBox",
		text = "继续法术",
		desc = "",
	},
	{
		key = "anyinraid",
		widget = "EditBox",
		text = "多目标查询",
		desc = "help扫描友善单位\npveharm扫描敌对单位(pve)\npvpharm扫描敌对单位(pvp)\nall扫描全部单位(pvp)\n",
	},
	{
		key = "heading",
		widget = "SimpleGroup",
		text = "",
		width = "fill",
	},
	{
		key = "upper",
		widget = "Button",
		text = "上移",
		desc = "",
			width = "x2",
	},
	{
		key = "lower",
		widget = "Button",
		text = "下移",
		desc = "",
			width = "x2",
	},
	{
		key = "new",
		widget = "Button",
		text = "新建",
		desc = "",
	},
	{
		key = "inport",
		widget = "Button",
		text = "导入",
		desc = "",
	},
	{
		key = "export",
		widget = "Button",
		text = "导出",
		desc = "",
	},
	{
		key = "delete",
		widget = "Button",
		text = "删除",
		desc = "按住Ctrl",
	},
	{
		key = "heading",
		widget = "SimpleGroup",
		text = "",
		width = "fill",
	},
	{
		key = "icon",
		widget = "EditBox",
		text = "图标名称(或路径)",
		desc = "留空则使用技能图标",
		width = 320,
	},
	{
		key = "cd",
		widget = "EditBox",
		text = "冷却时间",
		desc = "留空则使用技能冷却",
	},
	{
		key = "heading",
		widget = "SimpleGroup",
		text = "",
		width = "fill",
	},
	{
		key = "tarmin",
		widget = "Slider",
		text = "最小目标数",
		min = 0,
		max = 10,
		step = 1,
		desc = "",
			width = "x2",
	},
	{
		key = "tarmax",
		widget = "Slider",
		text = "最大目标数",
		min = 0,
		max = 10,
		step = 1,
		desc = "",
			width = "x2",
	},
}
	local filterConfigWidgets = {
		{
			key = "type",
			widget = "Dropdown",
			text = "选择类型",
			desc = "",
			width = "x2",
		},
		{
			key = "subtype",
			widget = "Dropdown",
			text = "子类型",
			desc = "",
			width = "x2",
		},
		{
			key = "note",
			widget = "EditBox",
			text = "注释",
			desc = "会显示在左面的列表中,方便查找",
			width = "x2",
		},
		{
			key = "oppo",
			widget = "CheckBox",
			text = "翻转结果",
			desc = "选中则翻转结果",
			width = "x2",
		},
		{
			key = "heading",
			widget = "SimpleGroup",
			text = "",
			width = "fill",
		},
		
		{
			key = "new",
			widget = "Button",
			text = "新建",
			desc = "",
		},
		{
			key = "inport",
			widget = "Button",
			text = "导入",
			desc = "",
		},
		{
			key = "export",
			widget = "Button",
			text = "导出",
			desc = "",
		},
		{
			key = "delete",
			widget = "Button",
			text = "删除",
			desc = "按住Ctrl",
		},
		
		{
			key = "upper",
			widget = "Button",
			text = "上移",
			desc = "",
		},
		{
			key = "lower",
			widget = "Button",
			text = "下移",
			desc = "",
		},
		{
			key = "heading",
			widget = "SimpleGroup",
			text = "",
			width = "fill",
		},
		{
			key = "name",
			widget = "MultiLineEditBox",
			text = "名称",
			desc = "",
			width = "x4",
		},
		{
			key = "unit",
			widget = "EditBox",
			text = "单位",
			desc = "",
			width = "x2",
		},
		{
			key = "greater",
			widget = "CheckBox",
			text = "大于",
			desc = "",
			width = "x2",
		},
		{
			key = "value",
			widget = "EditBox",
			text = "数值",
			desc = "",
			width = "x2",
		},
	}
function mod:CreateMainConfigGroup()
	local group = AceGUI:Create("ScrollFrame")
	group:SetLayout("Flow")
	
	local widgets = spellConfigWidgets
	for i,v in ipairs(widgets) do 
		local widget = AceGUI:Create(v.widget)
		if widget.SetLabel then
			widget:SetLabel(v.text)
		elseif widget.SetText then
			widget:SetText(v.text)
		end
		if v.min and v.max and v.step and widget.SetSliderValues then
			widget:SetSliderValues(v.min,v.max,v.step)
		end
		SetDescription(widget,v.desc)
		if v.width == "fill" then
			widget:SetFullWidth(true)
		elseif v.width == "x2" then
			widget:SetWidth(160)
		else
			widget:SetWidth(v.width or 80)
		end
		group:AddChild(widget)
		group[v.key] = widget
	end
	
	group.spell:SetCallback("OnEnterPressed",function(widget,event,text) 
		if text == "" then
			text = "等待"
		end
		self.currentSpellArray[self.currentSpellIndex].spell = text 
		self.currentSpellArray[self.currentSpellIndex].spellId = nil
		self.currentSpellArray[self.currentSpellIndex].spellName = nil
		self.currentSpellArray[self.currentSpellIndex].cd = nil
		
		self:UpdateSpellTreeGroup()
	end)
	local spellDraged = function(frame)
		local self = frame.obj
		local type, id, info = GetCursorInfo()
		if type == "item" then
			local spellId = "i"..id
			self:SetText(spellId)
			self:Fire("OnEnterPressed", spellId)
			ClearCursor()
		elseif type == "spell" then
			local _,_,_,_,_,_,spellId = GetSpellInfo(id, info)
			self:SetText(spellId)
			self:Fire("OnEnterPressed", spellId)
			ClearCursor()
		elseif type == "mount" then
			local _,name = C_MountJournal.GetMountInfo(info)
			self:SetText(name)
			self:Fire("OnEnterPressed", name)
			ClearCursor()
		end
		AceGUI:ClearFocus()
	end
	group.spell.editbox:SetScript("OnReceiveDrag", spellDraged)
	group.spell.editbox:SetScript("OnReceiveDrag", spellDraged)
	group.disable:SetCallback("OnValueChanged",function(widget,event,value) 
		self.currentSpellArray[self.currentSpellIndex].disable = value or nil 
		self:UpdateSpellTreeGroup()
	end)
	
	group.anyinraid:SetCallback("OnEnterPressed",function(widget,event,text) 
		if text == "" then
			text = nil
		end
		self.currentSpellArray[self.currentSpellIndex].anyinraid = text or nil 
		self:UpdateSpellTreeGroup()
	end)
	group.continue:SetCallback("OnValueChanged",function(widget,event,value) 
		self.currentSpellArray[self.currentSpellIndex].continue = value or nil 
		self:UpdateSpellTreeGroup()
	end)
	
	group.upper:SetCallback("OnClick", function(widget,event)
		local currentSpellIndex = self.currentSpellIndex
		local swapSpellIndex = currentSpellIndex - 1
		if swapSpellIndex == 0 then
			return
		end
		local tmpSpell = self.currentSpellArray[swapSpellIndex]
		self.currentSpellArray[swapSpellIndex] = self.currentSpellArray[currentSpellIndex]
		self.currentSpellArray[currentSpellIndex] = tmpSpell
		self.currentSpellIndex = swapSpellIndex
		self:UpdateSpellTreeGroup()
	end)
	
	group.lower:SetCallback("OnClick", function(widget,event)
		local currentSpellIndex = self.currentSpellIndex
		local swapSpellIndex = currentSpellIndex + 1
		if swapSpellIndex == #(self.currentSpellArray) + 1 then
			return
		end
		local tmpSpell = self.currentSpellArray[swapSpellIndex]
		self.currentSpellArray[swapSpellIndex] = self.currentSpellArray[currentSpellIndex]
		self.currentSpellArray[currentSpellIndex] = tmpSpell
		self.currentSpellIndex = swapSpellIndex
		self:UpdateSpellTreeGroup()
	end)
	
	group.new:SetCallback("OnClick", function(widget,event)
		local currentSpellIndex = self.currentSpellIndex or 0
		self:NewSpell({},currentSpellIndex+1)
		self.currentSpellIndex = currentSpellIndex + 1
		self:UpdateSpellTreeGroup()
	end)
	
	group.note:SetCallback("OnEnterPressed",function(widget,event,text) 
		if text == "" then
			text = nil
		end
		self.currentSpellArray[self.currentSpellIndex].note = text 
		self:UpdateSpellTreeGroup()
	end)
	
	group.inport:SetCallback("OnClick", function(widget,event)
		parent.inportStatus = {self.currentFilterPath,self.currentSpellIndex,AirjAutoKey.selectedIndex}
		parent:Inport()
	end)
	
	group.export:SetCallback("OnClick", function(widget,event)
		parent:Export("spell",self.currentSpellArray[self.currentSpellIndex])
	end)

	group.delete:SetCallback("OnClick", function(widget,event)
		if not IsControlKeyDown() then return end
		tremove(self.currentSpellArray,self.currentSpellIndex)
		if self.currentSpellIndex > #self.currentSpellArray then
			if #self.currentSpellArray == 0 then
				self.currentSpellIndex = nil
			else
				self.currentSpellIndex = #self.currentSpellArray
			end
		end
		self:UpdateSpellTreeGroup()
	end)
	
	group.icon:SetCallback("OnEnterPressed",function(widget,event,text) 
		if text == "" then
			text = nil
		end
		self.currentSpellArray[self.currentSpellIndex].icon = text 
	end)
	
	group.cd:SetCallback("OnEnterPressed",function(widget,event,text) 
		local cd
		if text == "" then
		else
			cd = tonumber(text) 
		end
		self.currentSpellArray[self.currentSpellIndex].cd = cd
	end)
	
	group.tarmin:SetCallback("OnMouseUp", function(widget,event,value)
		self.currentSpellArray[self.currentSpellIndex].tarmin = value 
	end)
	
	group.tarmax:SetCallback("OnMouseUp", function(widget,event,value)
		self.currentSpellArray[self.currentSpellIndex].tarmax = value 
	end)
	
	--filters stuff
	local filtersHeading = AceGUI:Create("Heading")
	filtersHeading:SetText("过滤器")
	filtersHeading:SetFullWidth(true)
	group:AddChild(filtersHeading)
	
	local filtersGroup = AceGUI:Create("TreeGroup")
	filtersGroup:SetTreeWidth(160,true)
	group:AddChild(filtersGroup)
	group.filtersGroup = filtersGroup
	
	filtersGroup:SetFullWidth(true)
	filtersGroup:SetTree({})
	filtersGroup:SetCallback("OnGroupSelected",function(widget,event,group)
		self.currentFilterPath = group
		self:UpdateFilterConfigGroup()
	end)
	filtersGroup:SetLayout("Flow")
	
	for i,v in ipairs(filterConfigWidgets) do 
		local widget = AceGUI:Create(v.widget)
		if widget.SetLabel then
			widget:SetLabel(v.text)
		elseif widget.SetText then
			widget:SetText(v.text)
		end
		if v.min and v.max and v.step and widget.SetSliderValues then
			widget:SetSliderValues(v.min,v.max,v.step)
		end
		SetDescription(widget,v.desc)
		if v.width == "fill" then
			widget:SetFullWidth(true)
		elseif v.width == "x2" then
			widget:SetWidth(160)
		elseif v.width == "x4" then
			widget:SetWidth(320)
		else
			widget:SetWidth(v.width or 80)
		end
		filtersGroup:AddChild(widget)
		group["filter_"..v.key] = widget
	end
	
	group.filter_type:SetList(typeList,typeOrder)
	for k,v in group.filter_type.pullout:IterateItems() do
		--SetDescription(v,typeDesc[k])
	end
	group.filter_type:SetCallback("OnValueChanged",function(widget,event,key)
		local filter = self:GetCurrentSpellFilter() 
		filter.type = key
		self:UpdateFilterTreeGroup()
	end)
	
	group.filter_subtype:SetCallback("OnValueChanged",function(widget,event,key)
		local filter = self:GetCurrentSpellFilter() 
		filter.subtype = key
		self:UpdateFilterTreeGroup()
	end)
	
	group.filter_note:SetCallback("OnEnterPressed",function(widget,event,text)
		local filter = self:GetCurrentSpellFilter() 
		if text == "" then
			text = nil
		end
		filter.note = text
		self:UpdateFilterTreeGroup()
	end)
	
	group.filter_oppo:SetCallback("OnValueChanged",function(widget,event,checked)
		local filter = self:GetCurrentSpellFilter() 
		filter.oppo = checked or nil
	end)
	
	group.filter_new:SetCallback("OnClick",function(widget,event)
		self.currentFilterPath = self:NextFilterPath()
		self:NewFilter({})
	end)
	
	group.filter_inport:SetCallback("OnClick", function(widget,event)
		parent.inportStatus = {self.currentFilterPath,self.currentSpellIndex,AirjAutoKey.selectedIndex}
		parent:Inport()
	end)
	
	group.filter_export:SetCallback("OnClick", function(widget,event)
		local filter = self:GetCurrentSpellFilter() 
		parent:Export("filter",filter)
	end)
	group.filter_delete:SetCallback("OnClick", function(widget,event)
		if not IsControlKeyDown() then return end
		local spell = self.currentSpellArray[self.currentSpellIndex]
		local pathstr = {strsplit("\001",self.currentFilterPath)}
		local paths = {}
		for i,v in ipairs(pathstr) do
			paths[i] = tonumber(v)
		end
		local filter = spell.filter
		for i = 1,#paths -1 do
			filter = filter[paths[i]]
		end
		tremove(filter,paths[#paths])
		self:UpdateFilterTreeGroup()
	end)
	group.filter_upper:SetCallback("OnClick", function(widget,event)
		
		local spell = self.currentSpellArray[self.currentSpellIndex]
		local pathstr = {strsplit("\001",self.currentFilterPath)}
		local paths = {}
		for i,v in ipairs(pathstr) do
			paths[i] = tonumber(v)
		end
		local filter = spell.filter
		for i = 1,#paths -1 do
			filter = filter[paths[i]]
		end
		local index = paths[#paths]
		if index ~= 1 then
			local t = filter[index]
			filter[index] = filter[index-1]
			filter[index-1] = t
			index = index - 1
		end
		paths[#paths] = index
		self.currentFilterPath = table.concat(paths,"\001")
		self:UpdateFilterTreeGroup()
	end)
	
	group.filter_lower:SetCallback("OnClick", function(widget,event)
		
		local spell = self.currentSpellArray[self.currentSpellIndex]
		local pathstr = {strsplit("\001",self.currentFilterPath)}
		local paths = {}
		for i,v in ipairs(pathstr) do
			paths[i] = tonumber(v)
		end
		local filter = spell.filter
		for i = 1,#paths -1 do
			filter = filter[paths[i]]
		end
		local index = paths[#paths]
		if index ~= #filter then
			local t = filter[index]
			filter[index] = filter[index+1]
			filter[index+1] = t
			index = index+1
		end
		paths[#paths] = index
		self.currentFilterPath = table.concat(paths,"\001")
		self:UpdateFilterTreeGroup()
	end)
	
	
	
	group.filter_name:SetHeight(500)
	
	local onDrag = function(self,...)
		AIRJTEST = self
		local editBox = self.obj
		local type, id, info = GetCursorInfo()
		local text
		if type == "item" then
			local spellId = "i"..id
			text = spellId
		elseif type == "spell" then
			local _,_,_,_,_,_,spellId = GetSpellInfo(id, info)
			text = spellId
		elseif type == "mount" then
			local _,name = C_MountJournal.GetMountInfo(info)
			text = name
		end
		if text then
			if editBox:GetText() then
				text = editBox:GetText()..","..text
			end
			editBox:SetText(text)
			editBox:Fire("OnEnterPressed", text)
		end
		ClearCursor()
		AceGUI:ClearFocus()
	end
	
	group.filter_name.scrollFrame:SetScript("OnReceiveDrag", onDrag)
	group.filter_name.editBox:SetScript("OnReceiveDrag", onDrag)
	group.filter_name.editBox:SetScript("OnMouseDown", onDrag)
	group.filter_name:SetCallback("OnEnterPressed",function(widget,event,text)
		local filter = self:GetCurrentSpellFilter() 
		text = gsub(text,"\n",",") 
		local lasttext = ""
		while lasttext~= text do
			lasttext = text
			text = gsub(text,", ",",")
			text = gsub(text," ,",",")
		end
		local nameTable = {strsplit(",",text)}
		if #nameTable <=1 then
			if text == "" then
				text = nil
			elseif tonumber(text) then
				text = tonumber(text)
			end
			filter.name = text
		else
			local tab = {}
			for k,v in ipairs(nameTable) do
				if v ~="" then
					tinsert(tab,tonumber(v) or v)
				end
			end
			if #tab <= 1 then
				tab = tab[1]
			end
			filter.name = tab
		end
		self:UpdateFilterTreeGroup()
	end)
	
	group.filter_unit:SetCallback("OnEnterPressed",function(widget,event,text)
		local filter = self:GetCurrentSpellFilter() 
		local nameTable = {strsplit(",",text)}
		if #nameTable <=1 then
			if text == "" then
				text = nil
			elseif tonumber(text) then
				text = tonumber(text)
			end
			filter.unit = text
		else
			local tab = {}
			for k,v in pairs(nameTable) do
				tab[k] = tonumber(v) or v
			end
			filter.unit = tab
		end
		self:UpdateFilterTreeGroup()
	end)
	
	group.filter_greater:SetCallback("OnValueChanged",function(widget,event,checked)
		local filter = self:GetCurrentSpellFilter() 
		filter.greater = checked or nil
		self:UpdateFilterTreeGroup()
	end)
	
	group.filter_value:SetCallback("OnEnterPressed",function(widget,event,text)
		local filter = self:GetCurrentSpellFilter() 
		if text == "" then
			text = nil
		elseif tonumber(text) then
			text = tonumber(text)
		end
		filter.value = text
		self:UpdateFilterTreeGroup()
	end)
	
	self.mainConfigGroup = group
end

function mod:NextFilterPath(path)
	path = path or self.currentFilterPath 
	local filter = self:GetCurrentSpellFilter() 
	local pathstr = {strsplit("\001",path)}
	local paths = {}
	for i,v in ipairs(pathstr) do
		paths[i] = tonumber(v)
	end
	if not filter then
	elseif filter.group or filter.type == "GROUP" then
		paths[#paths+1] = 1
	else
		paths[#paths] = paths[#paths] + 1
	end
	local path = table.concat(paths,"\001")
	return tonumber(path) or path
end

local function GetFilter(filter,path)
	if path and path ~= "" then
		local thisPath, nextPath = strsplit("\001",path,2)
		return GetFilter(filter[tonumber(thisPath)],nextPath)
	else
		return filter
	end
end

function mod:GetCurrentSpellFilter() 
	local spell = self.currentSpellArray[self.currentSpellIndex]
	if not spell then return end
	local path = self.currentFilterPath
	return GetFilter(spell.filter,path)
end

function mod:UpdateSpellTreeGroup()
	local spellArray = self.currentSpellArray or {}
	local mainGroup = self.mainGroup
	local tree = {}
	for i,v in ipairs(spellArray) do
		local spellName = strsplit("_", v.spell or "") or ""
		local icon = GetSpellTexture(v.icon or "") or v.icon or GetSpellTexture(spellName)
		local text = v.spell
		if not text then
			--dump(v)
			if v.filter and v.filter[1] and v.filter[1].type then
				local filter = AirjAutoKey.filterTypes[v.filter[1].type]
				if filter then
					text = filter.name
				end
			end
		end
		text = text or "未定义"
		if v.note then
			text = text.." - "..v.note
		else
			text = text.." - "..tostring(i)
		end
		if v.anyinraid then
			text = "**"..text
		else
			text = "  "..text
		end
		if v.disable then
			text = "|cff7f00ff" .. text .. "|r"
		elseif AirjAutoKey.macroArray[v.spell or "_"] then
			text = "|cff00ff00" .. text .. "|r"
		end
		tinsert(tree,{value = i,text = text,icon = icon or "",})
	end
	mainGroup:SetTree(tree,true)
	mainGroup:Select(self.currentSpellIndex)
--	self:UpdateMainConfigGroup()
end

function mod:UpdateMainConfigGroup()
	local group = self.mainConfigGroup
	if not group then
		return
	end
	local index = self.currentSpellIndex
	local spell = self.currentSpellArray[index]
	
	for k,v in pairs(spellConfigWidgets) do
		local key = v.key
		if key and group[key] and group[key].SetDisabled then
			group[key]:SetDisabled(self.isDefault or (spell == nil))
		end
	end
	group.new:SetDisabled(self.isDefault)
	group.export:SetDisabled((spell == nil))
	if not spell then
		spell = {}
	end
	
	group.spell:SetText(spell.spell or "未定义")
	
	group.disable:SetValue(spell.disable or false)
	group.anyinraid:SetText(type(spell.anyinraid)=="boolean" and "all" or spell.anyinraid or "")
	group.continue:SetValue(spell.continue or false)
	group.note:SetText(spell.note or "")
	local spellName = strsplit("_", spell.spell or "")
	local icon = GetSpellTexture(spell.icon or "") or spell.icon or GetSpellTexture(spellName) or ""
	group.icon:SetText(icon)
	local cd = spell.cd or (GetSpellBaseCooldown(spellName) or 0)/1000 or 0
	group.cd:SetText(cd or "0")
	group.tarmin:SetValue(spell.tarmin or 0)
	group.tarmax:SetValue(spell.tarmax or 10)
	group.upper:SetDisabled(self.isDefault or not index or index == 1)
	group.lower:SetDisabled(self.isDefault or not index or index == #self.currentSpellArray)

	self:UpdateFilterTreeGroup()
	group:DoLayout()
end

function mod:GetFilterTreeElement(filter,isRoot)
	local element = {}
	if filter.group or filter.type == "GROUP" or isRoot then
		element.children = {}
		for k,v in ipairs(filter) do
			element.children[k] = self:GetFilterTreeElement(v)
			element.children[k].value = k
		end
	end
	element.text = filter.type and typeList[filter.type] or filter.fcn and typeList.FCN or filter.group and typeList.GROUP or "未定义"
	local	name
	if type(filter.name) == "table" then
		name = filter.name[1]
	else
		name = filter.name
	end
	element.icon = name and GetSpellTexture(tonumber(name) or name) or ""
	
	if filter.note then
		element.text = element.text.." - "..filter.note
	end
	local status = pcall(AirjAutoKey.CheckFilter, AirjAutoKey, filter)
	if not status then
		local text = element.text
		local pos = strfind(text,"|c")
		if pos then
			text = strsub(text,1,pos-1)..strsub(text,pos+10)
			text = gsub(text,"|r","")
		end
		element.text = "|cffff0000"..text.."|r"
	end
	return isRoot and element.children or element
end

function mod:UpdateFilterTreeGroup()
	local index = self.currentSpellIndex
	local spell = self.currentSpellArray[index]
	local group = self.mainConfigGroup
	local filtersGroup = group.filtersGroup
	if spell then
		local filterArray = spell.filter
		local tree = self:GetFilterTreeElement(filterArray,true)
		filtersGroup:SetTree(tree,true)
		filtersGroup:SelectByValue(tonumber(self.currentFilterPath) or self.currentFilterPath)
	else
		filtersGroup:SetTree({},true)
		self:UpdateFilterConfigGroup()
	end
--	
end

function mod:UpdateFilterConfigGroup()
	local group = self.mainConfigGroup
	local currentFilter = self:GetCurrentSpellFilter()
	for k,v in pairs(filterConfigWidgets) do
		local key = v.key
		if key and group["filter_"..key] and group["filter_"..key].SetDisabled then
			group["filter_"..key]:SetDisabled(self.isDefault or (currentFilter == nil))
		end
	end
	if self.currentSpellArray[self.currentSpellIndex] then
		group.filter_new:SetDisabled(self.isDefault)
	end
	group.filter_export:SetDisabled((currentFilter == nil))
	
	currentFilter = currentFilter or {}
	local maintype,subtype = currentFilter.type,currentFilter.subtype
	if not maintype and currentFilter.fcn then
		maintype,subtype = "FCN",currentFilter.fcn
	elseif not maintype and currentFilter.group then 
		maintype = "GROUP"
	end
	group.filter_type:SetValue(maintype or "_")
	self:UpdateFilterConfigGroupType()
	group.filter_subtype:SetValue(subtype and tostring(subtype) or subtype or "_")
	group.filter_oppo:SetValue(currentFilter.oppo)
	local nameText = currentFilter.name
	if type(nameText) == "table" then
		nameText = table.concat(nameText,",")
	end
	group.filter_name:SetText(nameText or "")
	group.filter_note:SetText(currentFilter.note)
	
	local unitText = currentFilter.unit
	if type(unitText) == "table" then
		unitText = table.concat(unitText,",")
	end
	group.filter_unit:SetText(unitText or "player")
	group.filter_value:SetText(currentFilter.value or currentFilter.value or 0)
	group.filter_greater:SetValue(currentFilter.greater)
end

function mod:UpdateFilterConfigGroupType()
	local filter = self:GetCurrentSpellFilter() or {}
	local key = filter.type
	if key == self.lastType then
		--return
	end
	self.lastType = key
	local typeInfo = AirjAutoKey.filterTypes[key] or {}
	local keys = typeInfo.keys or {}
	local subtypes = typeInfo.subtypes
	if key == "GROUP" then
		keys = {
			unit = {desc = "'raid'搜索全队"},
			value = {name = "数量",desc = "unit = 'raid'时的数量"},
			greater = {},
		}
	--	filter.group = true
	else
	--	filter.group = nil
	end
	local group = self.mainConfigGroup
	local list
	local isfcn
	if key == "FCN" then
		isfcn = true
		group.filter_subtype:SetDisabled(self.isDefault or false)
		group.filter_subtype:SetLabel("自定义函数")
		list = {_ = "请选择"}
		for k,v in pairs(AirjAutoKey.fcnArray) do
			list[k] = k
		end
	elseif subtypes then
		group.filter_subtype:SetDisabled(self.isDefault or false)
		group.filter_subtype:SetLabel("子类型")
		list = {_ = "默认"}
		for k,v in pairs(subtypes) do
			list[tostring(k)] = v.name
		end
	else
		group.filter_subtype:SetDisabled(self.isDefault or true)
		group.filter_subtype:SetLabel("无可用子类型")
		list = {_ = "默认"}
	end
	group.filter_subtype:SetList(list)
	local infoKeys = 
	{
		"name",
		"unit",
		"value",
		"greater",
	}
	local default = 
	{
		["name"] = "名称",
		["unit"] = "单位",
		["value"] = "数值",
		["greater"] = "大于",
	}
	
	local defaultDesc = 
	{
		["name"] = "名称",
		["unit"] = "单位",
		["value"] = "数值",
		["greater"] = "选中则为小于等于,否则为大于",
	}
	
	for k,v in pairs(infoKeys) do
		local widget = group["filter_"..v]
		if keys[v] or isfcn then
			widget:SetDisabled(self.isDefault or false)
			widget:SetLabel(keys[v] and keys[v].name or default[v])
			SetDescription(widget,keys[v] and (keys[v].desc or keys[v].name) or defaultDesc[v] or "")
		else
			widget:SetDisabled(self.isDefault or true)
			filter[v] = nil
			widget:SetLabel(default[v])
			SetDescription(widget,defaultDesc[v] or default[v] or "")
		end
	end
			
end

function mod:NewSpell(spell,index)
	local spellArray = self.currentSpellArray
	if not index then 
		index = self.currentSpellIndex 
	else
		self.currentSpellIndex = index
	end
	spell.filter = spell.filter or {}
	tinsert(spellArray,index,spell)
	self:UpdateSpellTreeGroup()
end

function mod:NewFilter(filter,index,path)
	if not path then 
		path = self.currentFilterPath 
	else
		self.currentFilterPath = path
	end
	if not index then 
		index = self.currentSpellIndex 
	else
		self.currentSpellIndex = index
	end
	local pathstr = {strsplit("\001",path)}
	local paths = {}
	for i,v in ipairs(pathstr) do
		paths[i] = tonumber(v)
	end
	local lastPath = paths[#paths]
	paths[#paths] = nil
	local parentPath = table.concat(paths,"\001")
	local spell = self.currentSpellArray[index]
	local parentFilter = GetFilter(spell.filter,parentPath)
	tinsert(parentFilter,lastPath,filter)
	self:UpdateFilterTreeGroup()
end

function mod:SpellSetting()
	local mainGroup = self.mainGroup
	if not mainGroup then
		mainGroup = AceGUI:Create("TreeGroup")
		mainGroup:SetTreeWidth(200,true)
		mainGroup:SetCallback("OnGroupSelected",function(widget,event,uniquevalue)
			self.currentSpellIndex = uniquevalue
			self.currentFilterPath = 1
			self:UpdateMainConfigGroup()
		end)
		self.mainGroup = mainGroup
		local tabGroup = parent.tabGroup
		tabGroup:AddChild(mainGroup)
	end
	if not self.mainConfigGroup then
		self:CreateMainConfigGroup()
		mainGroup:SetLayout("Fill")
		mainGroup:AddChild(self.mainConfigGroup)
	end
	self:UpdateSpellTreeGroup()
	parent:SelectTab(mainGroup)
end

function parent:SpellSetting()
	if mod.currentSpellArray ~= AirjAutoKey.spellArray then
		mod.currentSpellArray = AirjAutoKey.spellArray
		local spell
		mod.currentSpellIndex,spell = next(mod.currentSpellArray)
		local filterArray = spell and spell.filter or {}
		mod.currentFilterPath = next(filterArray)
		mod.isDefault = AirjAutoKey.rotationDB.isDefault
	end
	mod:SpellSetting()
end

parent:RegisterTab("SpellSetting","循环设置",mod)